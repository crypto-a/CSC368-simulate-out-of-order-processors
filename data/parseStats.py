#!/usr/bin/env python3

# # This script was generated by ChatGPT

import os
from collections import OrderedDict

STAT_KEYS = OrderedDict([
    # Fetch stats
    ("fetch_numInsts",      "system.cpu.fetchStats0.numInsts"),
    ("fetch_numOps",        "system.cpu.fetchStats0.numOps"),
    ("fetch_numBranches",   "system.cpu.fetchStats0.numBranches"),

    # Execute stats
    ("exec_numIntAluAcc",   "system.cpu.executeStats0.numIntAluAccesses"),
    ("exec_numFpAluAcc",    "system.cpu.executeStats0.numFpAluAccesses"),

    # Commit stats
    ("commit_numInsts",     "system.cpu.commitStats0.numInsts"),
    ("commit_numIntInsts",  "system.cpu.commitStats0.numIntInsts"),
    ("commit_numFpInsts",   "system.cpu.commitStats0.numFpInsts"),
    ("commit_numLoads",     "system.cpu.commitStats0.numLoadInsts"),
    ("commit_numStores",    "system.cpu.commitStats0.numStoreInsts"),
    ("commit_numBranches",  "system.cpu.commitStats0.committedControl::IsControl"),
])

STATS_FILENAME = "stats.txt"
OUTPUT_FILENAME = "p2Stats.txt"

BEGIN_MARK = "Begin Simulation Statistics"
END_MARK   = "End Simulation Statistics"


def extract_second_block(lines):
    """Return the lines belonging to the 2nd simulation stats block."""
    begin_idxs = [i for i, l in enumerate(lines) if BEGIN_MARK in l]
    if not begin_idxs:
        return []

    # if only one block exists, just use that one
    if len(begin_idxs) == 1:
        start = begin_idxs[0] + 1
    else:
        start = begin_idxs[1] + 1  # second "Begin..."

    # find the matching End after 'start'
    end = len(lines)
    for j in range(start, len(lines)):
        if END_MARK in lines[j]:
            end = j
            break

    return lines[start:end]


def parse_stats_block(block_lines):
    """Parse a stats block into a dict: {name: value}."""
    stats = {}
    for line in block_lines:
        line = line.strip()
        if not line or line.startswith("-"):
            continue
        # typical gem5 line: "name value # comment"
        parts = line.split()
        if len(parts) < 2:
            continue
        name, value = parts[0], parts[1]
        stats[name] = value
    return stats


def find_benchmark_dirs():
    """Return list of subdirectories that contain a stats.txt file."""
    dirs = []
    for entry in os.listdir("."):
        if not os.path.isdir(entry):
            continue
        stats_path = os.path.join(entry, STATS_FILENAME)
        if os.path.isfile(stats_path):
            dirs.append(entry)
    return sorted(dirs)


def main():
    bench_dirs = find_benchmark_dirs()
    if not bench_dirs:
        print("No benchmark directories with stats.txt found.")
        return

    rows = []

    for d in bench_dirs:
        stats_path = os.path.join(d, STATS_FILENAME)
        with open(stats_path, "r") as f:
            lines = f.readlines()

        block = extract_second_block(lines)
        stats_dict = parse_stats_block(block)

        row = [d]
        for label, statname in STAT_KEYS.items():
            val = stats_dict.get(statname, "NA")
            row.append(val)
        rows.append(row)

    # write table
    with open(OUTPUT_FILENAME, "w") as out:
        # header
        headers = ["benchmark"] + list(STAT_KEYS.keys())
        out.write("\t".join(headers) + "\n")
        # rows
        for row in rows:
            out.write("\t".join(row) + "\n")

    print(f"Wrote characterization table to {OUTPUT_FILENAME}")


if __name__ == "__main__":
    main()
